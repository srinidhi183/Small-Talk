#llm_utils.py
from openai import OpenAI
from config import OPENAI_API_KEY, PERPLEXITY_API_KEY
import os
import json
import re
import requests

# --- add near the top of llm_utils.py ---
def _safe_format_prompt(template: str, **values) -> str:
    # Protect the placeholders you actually use
    keep = {
        "{keywords}": "__KW__",
        "{news}": "__NEWS__",
        "{subcategories}": "__SUBCATS__",
        "{allow_options}": "__ALLOW__",
    }
    for k, token in keep.items():
        template = template.replace(k, token)

    # Escape all remaining braces so .format won't choke on JSON/examples
    template = template.replace("{", "{{").replace("}", "}}")

    # Restore real placeholders
    for k, token in keep.items():
        template = template.replace(token, k)

    # Now safe to format
    return template.format(**values)


def get_llm_response(prompt):
    """
    Call the LLM (using OpenAI's API) to generate a response.

    Args:
        prompt (str): The input prompt to be sent to the language model.

    Returns:
        str or None: The response generated by the language model, or None if an error occurs.
    """
    client = OpenAI(api_key = OPENAI_API_KEY)
    try:
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",  # or another model if desired
            messages=[
                #{"role": "system", "content": "You are a helpful assistant."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.7,
            #max_completion_tokens = 5000
        )
        llm_output = response.choices[0].message.content.strip()
        return llm_output
    except Exception as e:
        print("Error during LLM call:", e)
        return 


def build_prompt(
    prompt_type,
    prompt_version,
    keywords=None,
    article_text=None,
    extra_links=None,
    news=None,
    reference_url=None,
    allow_options = False,
    subcategories=None,
    template_dir="prompts"
):
    """
    Build a prompt string from input parameters and a template file.

    Args:
        prompt_type (str): Type of the prompt template to use.
        prompt_version (str): Version of the prompt template.
        keywords (list[str], optional): Keywords to include in the prompt.
        article_text (list[str], optional): Article contents to include.
        extra_links (list[str], optional): Extra links to include.
        news (str, optional): News content to include.
        reference_url (str, optional): Reference URL to include.
        allow_options (bool): Whether to allow options in the prompt.
        template_dir (str): Directory where the prompt templates are stored.

    Returns:
        str: The filled-in prompt based on the template and provided data.
    """
    keywords_str = ", ".join(keywords) if keywords else ""
    article_text_str = "\n\n".join(article_text) if article_text else ""
    extra_links_str = "\n".join(extra_links) if extra_links else ""
    reference_url_str = reference_url if reference_url else ""
    news_str = news if news else ""

    with open(os.path.join(template_dir, f"{prompt_type}_{prompt_version}.txt"), "r", encoding="utf-8") as f:
        template = f.read()

    prompt = _safe_format_prompt(
    template,
    keywords=keywords_str,
    articles=article_text_str,
    extra_links=extra_links_str,
    news=news_str,
    reference_url=reference_url_str,
    allow_options=allow_options,
    subcategories=subcategories
    )


    return prompt




def generate_perplexity_output(system_content, user_content, API_KEY = PERPLEXITY_API_KEY):
    url = "https://api.perplexity.ai/chat/completions"

    payload = {
        "model": "sonar",
        "messages": [
            {
                "role": "system",
                "content": system_content
            },
            {
                "role": "user",
                "content": user_content
            }
        ]
    }
    headers = {
        "Authorization": f"Bearer {API_KEY}",
        "Content-Type": "application/json"
    }

    response = requests.request("POST", url, json=payload, headers=headers)

    return response.json()


def verify_and_fix_json(input_str):
    """
    Attempt to parse `input_str` as JSON. If it fails,
    apply a series of fixes, then re-parse. Return (parse_ok, final_json).

    Returns:
        tuple:
            parse_ok (bool): True if valid JSON was obtained (original or fixed).
            final_json (dict or list or None): The parsed JSON object, or None if fixes failed.
    """

    # Helper: Remove markdown code block markers (``` or ```json)
    def remove_markdown_code_block(s):
        """
        Remove markdown code fences from the string.

        Args:
            s (str): Input string possibly containing markdown-style code blocks.

        Returns:
            str: String with markdown fences removed.
        """
        lines = s.splitlines()
        # Remove starting ``` or ```json
        if lines and lines[0].strip().startswith("```"):
            lines = lines[1:]
        # Remove ending ```
        if lines and lines[-1].strip().startswith("```"):
            lines = lines[:-1]
        return "\n".join(lines)

    # Helper: Remove literal newlines inside JSON string literals by replacing them with a space.
    # This function preserves double quotes around the string.
    def remove_newlines_in_strings(s):
        """
        Replace literal newline characters inside quoted strings with a space.

        Args:
            s (str): Input string containing JSON.

        Returns:
            str: Updated string with newline characters replaced inside string values.
        """
        pattern = r'"((?:\\.|[^"\\])*)"'  # Regex to match string contents (handles escaped quotes too)

        def replacer(match):
            inner = match.group(1)
            # Replace literal newline characters with a space
            new_inner = inner.replace('\n', ' ')
            return '"' + new_inner + '"'

        return re.sub(pattern, replacer, s, flags=re.DOTALL)

    # STEP 1: Preprocess: remove markdown code fences & newlines in string literals
    preprocessed = remove_markdown_code_block(input_str)
    preprocessed = remove_newlines_in_strings(preprocessed)

    # Attempt to parse the preprocessed JSON
    try:
        parsed = json.loads(preprocessed)
        # If parsing works, return immediately
        return True, parsed
    except json.JSONDecodeError as error:
        # We'll attempt to fix the JSON below
        pass

    # STEP 2: Try to fix the JSON with heuristics
    try:
        fixed_string = preprocessed

        # 2a. Remove lingering triple backticks (edge case)
        fixed_string = re.sub(r'^```[a-zA-Z]*\s*', '', fixed_string)
        fixed_string = re.sub(r'\s*```$', '', fixed_string)

        # 2b. Fix missing commas between lines that appear to have valid JSON pairs
        lines = fixed_string.splitlines()
        for i in range(len(lines) - 1):
            current_line = lines[i].rstrip()
            next_line = lines[i + 1].lstrip()

            # If current line ends with a literal or true/false/null
            if (current_line.endswith('"') or 
                re.search(r'[0-9]$', current_line) or
                current_line.endswith('true') or 
                current_line.endswith('false') or
                current_line.endswith('null')):

                # And next line starts like a key or unquoted text that might be a key
                if (next_line.startswith('"') or re.match(r'^[a-zA-Z_]', next_line)):
                    # If there's no trailing comma, add it
                    if not current_line.endswith(','):
                        lines[i] = current_line + ','

        fixed_string = "\n".join(lines)

        # 2c. Add missing quotes around keys: from { key: "value" } to { "key": "value" }
        fixed_string = re.sub(r'([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:', r'\1"\2":', fixed_string)

        # 2d. Remove trailing commas before closing braces/brackets
        fixed_string = re.sub(r',\s*([}\]])', r'\1', fixed_string)

        # 2e. Fix missing quotes around string values (somewhat simplistic)
        # e.g. : key -> : "key"
        fixed_string = re.sub(r':\s*([a-zA-Z0-9_][^{}\[\]"\',:}\]]*[a-zA-Z0-9_])', r': "\1"', fixed_string)

        # 2f. Replace undefined or NaN with null
        fixed_string = re.sub(r':\s*undefined', r': null', fixed_string)
        fixed_string = re.sub(r':\s*NaN', r': null', fixed_string)

        # 2g. Remove newlines inside string literals again
        fixed_string = remove_newlines_in_strings(fixed_string)

        # 2h. Balance braces/brackets if needed
        open_braces = fixed_string.count('{')
        close_braces = fixed_string.count('}')
        open_brackets = fixed_string.count('[')
        close_brackets = fixed_string.count(']')

        if open_braces > close_braces:
            fixed_string += '}' * (open_braces - close_braces)
        if open_brackets > close_brackets:
            fixed_string += ']' * (open_brackets - close_brackets)

        # Final attempt to parse
        parsed_fixed = json.loads(fixed_string)
        return True, parsed_fixed

    except Exception:
        # If we still fail, return parse_ok=False with no JSON
        return False, None



